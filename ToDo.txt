This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Tasks:
2. Finish promotion schema 
    - Promotion rules for units go from Dimensions -> AffineUnits (no information lost)
    - Promotion rules for UnionQuantity{T, U<:AbstractUnitLike} ALWAYS YIELD dimtype{U}
        - Converting from AbstractUnitLike to Dimensions loses no information with quantities
        - Get the promote_type of the two dimensions, to get resulting one
        - Make sure "dimtype" is defined for quantities, units, and dimensions (both types and values)
        - This requires a quantity_promote_rule() function that is differnet from promote_rule()
    - Promotion rules for quantities are determined by internal quantity type 
        - Lean on "narrowest_quantity" of the promoted value type
        - "narrowest_quantity" needs to apply PRIMARILY to types with fallback to instances
3. Consider adding a new error type called UnitConversionError
    - Provide a dimensional difference between units (recommend multiplying target units by $(units))
4. Finish mathematical functions
5. Add global constant "PARSABLE_DIMENSION_OUTPUT = Base.Ref(False)" for pretty-printing dimensions
    - AffineUnits from macros are always parsable, so pretty-printing dimesnions should be default
6. AffineUnits without symbols can be made parsable
    - Use parentheses around values to make sure they take priority (complex numbers have a `+` which can mess things up without brackets)
    - "(1.0(ustrip(u)) + 273.15)K"
7. Build basic tests
9. Consider using DispatchDoctor


Design Decisions:
1.  Unit/Quantity outputs should be clean and parsable with the uparse/qparse functions
2.  All quantity operations (even affine units) eagerly convert to base dimensional units 
        Displaying quantities with units not having symbol will convert to SI to emphasize this fact
3.  Registry is a module containing a single dict for a registry (AffineUnits because they are the most general)
        Users can easily create their own registries with the RegistryTools module that exports everythign you need
4.  String macros ({x}"...") and parse macros ({x}parse("...")) need the following versions:
        q: produce a Quantity{Float64, Dimensions} (si quantity representation, scale-restrictive)
        us: produce a ScalarUnits{Dimensions} (scaled unit representation, scale-restrictive)
        u: produce an AffineUnits{Dimensions} (affine unit represntation, general)
5.  Macros and parsers ARE NOT EXPORTED BY DEFAULT
        Instead, use "using Dimensionful.Registry" to export them manually
        This prevents polluting namespaces, and allows users to export macros from their own registries
6.  "u" and "us" variants assign the expression as their symbol

7.  You can feed a dictionary to {x}parse(str, dict), to use custom unit registries
        The dict will have have elements of AffineUnits{D} where D is a dimension object
        Build an {x}expression(str, dict) as well for easily building string macros



Considerations:
N.  Consider commutative macro for promote_rule to prevent repetition
        https://discourse.julialang.org/t/techniques-for-defining-commutative-functions/113406/5
